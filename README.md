# hw_kirill

1. [Заняття №1 Вступ в Пайтон](#module01)
2. [Заняття №2 Умови, Обробка помилок, Булева алгебра](#module02)
3. [Заняття №3 Цикли](#module03)
4. [Заняття №4 Функції](#module04)
4. [Заняття №5 Функції, аргументи, словники, кортежі, точка входу](#module05)



## Заняття №1. Вступ в Пайтон <a name="module01"></a>
Коли ми говоримо про програмування, перше, що спадає на думку - це набір інструкцій у файлі - вихідний код.

    print("Hello World!")
Вище приведений приклад виведення в консоль повідомлення **'Hello World!'**

Але символи, слова та фрази, які становлять програму, насправді незрозумілі для машини. Є крок, який виконується після 
написання програми, який конвертує вихідний код у файлі на набір інструкцій, зрозумілих комп'ютеру. Цим займається 
спеціальна програма: **компілятор** чи **інтерпретатор**.

### Python є високорівневою мовою програмування загального призначення, стандартна бібліотека якої включає великий набір корисних функцій.

#### На сьогоднішній день Python використовують у таких сферах:

* **Web-розробка**
* **Data Science**
* **Data Mining (отримання даних)**
* **Machine Learning (машинне навчання)**
* **Deep Learning (глибинне навчання)**

### Змінні

**Змінна** - це ім'я (псевдонім) для певної області пам'яті комп'ютера. Передбачається, що в цій пам'яті лежить корисна для розробника інформація, до якої необхідно звертатися неодноразово. Python, як і будь-яка інша мова програмування, працює з даними в пам'яті, до яких звертаються за допомогою імен (змінних).

**Змінна** — це комірка пам'яті, яка має ім'я і в якій можуть зберігатися дані.

    age = 20
    user1_age = 30
    user2_age = 30
    ADULT_THR = 18
    
    _do_not_use_this = 0

**Щодо іменування змінних у Python є три суворі правила:**

* Ім'я змінної в Python може складатися тільки з цифр, літер та знаків підкреслення _;
* Ім'я змінної не може починатися з цифри, а може зі знака нижнього підкреслення;
* Використання зарезервованих слів як ім'я змінної призведе до помилки.

**Список зарезервованих слів:**

    False, None, True, and, as, assert, async, await, break, class, continue, def, del, elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield

### Оператори та операнди
Операнди та оператори – це частини виразу. Оператори - визначають дію, операнди - те, з чим ця дія буде зроблена. У виразі 2 + 3 числа 3 і 2 будуть операндами, а знак + - оператором.

**Для Python визначено такі арифметичні оператори:**
* \+ \- * / // % **
* \+ : додавання 3 + 3 == 6
* \- : віднімання 5 - 3 == 2
* \* : множення 6 * 3 == 18
* \/ : ділення з остачею 15 / 2 == 7.5
* // : ділення без остачі 15 / 2 == 7
* % : остача від ділення
* \** : піднесення до степені 2 ** 3 == 8

**У пайтоні два знаки == це дорівнює!! Один знак = це присвоїти**

**Порядок виконання операцій такий самий як в математиці**

    x = 8**3 + 4*(2 + 2)
Спочатку 8**3, далі додавання 2+2, далі множення на 4 і додавання кінцеве

### Коментарі
Навіть ви у своєму коді за місяць мало що згадаєте. Тому дуже важливим інструментом розробника є коментарі. Також коментарі використовуються в тих випадках, коли виконувати частину програми не потрібно, але видаляти цю частину поки що зарано.

Коментарі в Python позначаються символом #, що після цього символу і до початку нового рядка інтерпретатор просто проігнорує.

    user_age = 7
    user_age = 18
    user_status = "adult"   # 'adult' for users older 18 and 'child' for younger

### Типи даних
Змінні можуть бути різного типу (зберігати інформацію у різних форматах):

* None — пустое значение и "никакой" тип данных.
* Числа (Numeric Type)
* Boolean — булев (логический) тип. Является подтипом целых чисел.
* Строки (Text Sequence Type)
### Тип None
У Python для позначення порожнього значення використовується None

    a = None

None використовується тоді, коли треба явно повернути якесь значення або створити його 
(зарезервувати ім'я для чогось), але по суті і сенсу ніякої корисної 
інформації поки що зберегти в цьому значенні не можна, навіть якого роду ця інформація 
(рядок чи число, або щось інше) поки що неясно. У разі застосовують None.

### Рядки
    hello_string = "Hello"
    world_string = 'World!'
Рядкові змінні - це впорядковані набори символів, що незмінюються. "Упорядковані" означає, що можна звертатися до символів рядків за індексом, копіювати їх, порівнювати, шукати. "Незмінні" означає, що одного разу створивши рядок, не можна змінити його вміст, можна тільки створити новий.

Для того, щоб Python зрозумів, що ви хочете створити рядкову змінну, необхідно укласти символи рядка в лапки. Для цього підійдуть як одинарні лапки”, так і подвійні”.

Наприклад, створимо змінну s, в якій зберігається рядок "Hello, World!":

    s = "Hello, World!"

### Операції над рядками
    s1 = "Hello,"
    s2 = "World!"
    joined_string = s1 + s2
Основною операцією, що реалізована для рядків, є об'єднання 
рядків (конкатенація). Конкатенація рядків реалізована з 
використанням оператора додавання +. Якщо "скласти" два або 
більше рядків, то в результаті отримаємо об'єднаний рядок. 
У прикладі вище joined_string дорівнюватиме "Hello, World!".

Для зручності вивода текста в Python використовуються спеціальну конструкцію f-рядки.

    name = "Oleg"
    hello_string = f"Hello, {name}!"
**f-рядок** — це такий шаблон, який дозволяє зручно генерувати рядок, підставляючи результат виконання виразів у потрібне місце в шаблоні.

Синтаксично f-рядок відрізняється від звичайного тим, що на початку рядка стоїть символ f. Інтерпретатор зрозуміє, що якщо
в такому рядку він зустріне символи фігурних дужок {}, то всередині них міститься вираз, який треба виконати і підставити результат у рядок.

У прикладі  **hello_string** дорівнюватиме **"Hello, Oleg!"**.

## Заняття №2. Умови, обробка винятків, Булева алгебра  <a name="module02"></a>

### Условия в Python
Условный оператор **if ... elif ... else** в Python в 
качестве условий может принимать переменные типа bool 
или любое выражение, которое он выполнит и результат 
преобразует в bool.

### Логические выражения
Когда в качестве условия в условный оператор мы передаем 
выражение, то выражение выполнится, а результат его 
выполнения будет преобразован в тип bool.

Для удобства в Python есть механизм неявного приведения 
любого типа к типу bool. Правила приведения к bool — 
интуитивны:

число 0 приводится к False (целое, дробное или комплексное);

    money = 0
    if money:
        print(f"You have {money} on your bank account")
    else:
        print("You have no money and no debts")

None приводится к False;

    result = None
    if result:
        print(result)
    else:
        print("Result is None, do something")

пустой контейнер (пустая строка и т.п.) приводятся к False

    user_name = input("Enter your name: ")
    if user_name:
        print(f"Hello {user_name}")
    else:
        print("Hi Anonym!")

### Булевая алгебра 
<a href='https://sites.google.com/site/programmirowanie/buleva-algebra' target='_blank'>Читать тут</a>

### Тернарные операции

Тернарные операторы — это те же условные выражения, 
но в сокращенной форме. Эти операторы возвращают что-то, в зависимости от 
того, является ли условие истиной или ложью.

    is_nice = True
    state = "nice" if is_nice else "not nice"
В Python также существует более краткий вариант тернарного оператора.

    some_data = None
    msg = some_data or "Не было возвращено данных"

**Вложенность условий может быть до бесконечности, рекомендуют не больше 3-4**

### Исключения
Преобразовать в **int** или **float** можно не любую строку. 
Например, если пользователь введет **'a'**, то 
интерпретатор не сможет определить, как преобразовать 
символ **a** в целое число, и вызовет исключение 
**ValueError**.

    int("a")
    ---------------------------------------------------------------------------
    ValueError                                Traceback (most recent call last)
    <ipython-input-6-d9136db7b558> in <module>
    ----> 1 int("a")
    
    ValueError: invalid literal for int() with base 10: 'a'

### Механизм обработки исключений виглядит так:
    val = 'a'
    try:
        val = int(val)
    except ValueError:
        print(f"val {val} is not a number")
    else:
        print(val > 0)
    finally:
        print("This will be printed anyway")

Сначала идёт try-делай, except-перехвати если ошибка(указать какая)
finally-блок который выполниться в любом случае


## Заняття №3 Цикли<a name="module03"></a>

### Циклы

Для того чтобы повторить какой-то блок кода несколько раз или повторять, пока выполняется некоторое условие, в Python реализованы циклы. Есть два вида циклов:

Цикл **for**, который ещё называют итерирующим, он перебирает все элементы некоторой последовательности;

Цикл **while**, который выполняется, пока выполняется некоторое условие.

Итерация (лат. iteratio «повторение») — повторение какого-либо действия. Итерация в программировании — организация обработки данных, при которой действия повторяются многократно, не приводя при этом к вызовам самих себя.

Одна итерация — это одно повторение.

### Цикл for
В Python цикл for используется для перебора всех элементов контейнеров или итерируемых объектов, например, списков. Инструкции, которые находятся в теле цикла, будут выполнены столько раз, сколько элементов в списке.

    message = "Never argue with stupid people, they will drag you down to their level and then beat you with experience."
    search = "r"
    result = 0
    for i in message:
        if i == search:
            result += 1
### Цикл while
    
    num = int(input("Enter the integer (0 to 100): "))
    sum = 0
    while num: 
        sum = sum + num
        num = num - 1
    print(sum)

## Заняття №4. Функції  <a name="module04"></a>

### Создание и вызов функций
Функции определяются при помощи зарезервированного слова def. После этого слова указывается имя функции, за которым следует пара скобок, в которых можно указать имена некоторых переменных, и заключительное двоеточие в конце строки. Далее следует блок команд, составляющих функцию. На примере можно видеть, что на самом деле это очень просто:

    def say_hello():
        print('Привет, Мир!')   # блок, принадлежащий функции
        # Конец функции say_hello()

    # вызов функции
    say_hello()

    # ещё один вызов функции
    say_hello()

### Аргументы функции
Функции могут принимать параметры, т.е. некоторые значения, передаваемые функции для того, чтобы она что-либо сделала с ними. Эти параметры похожи на переменные, за исключением того, что значение этих переменных указывается при вызове функции, и во время работы функции им уже присвоены их значения. Параметры указываются в скобках при объявлении функции и разделяются запятыми. Аналогично мы передаём значения, когда вызываем функцию. Обратите внимание на терминологию: имена, указанные в объявлении функции, называются параметрами, тогда как значения, которые вы передаёте в функцию при её вызове, – аргументами.

    def print_max(a, b):
        if a > b:
            print(a, 'максимально')
        elif a == b:
            print(a, 'равно', b)
        else:
            print(b, 'максимально')
    
    print_max(3, 4)  # прямая передача значений
    
    x = 5
    y = 7
    print_max(x, y)  # передача переменных в качестве аргументов

### Global
Чтобы присвоить некоторое значение переменной, определённой на высшем уровне программы (т.е. не в какой-либо области видимости, как то функции), необходимо указать Python, что её имя не локальное, а глобальное (global). Сделаем это при помощи зарезервированного слова global. Без применения зарезервированного слова global невозможно присвоить значение переменной, определённой за пределами функции.

    x = 50
    
    def func():
        global x
        print('x равно', x) # x равно 50
        x = 2
        print('Заменяем глобальное значение x на', x)   # Заменяем глобальное значение x на 2
    
    func()
    print('Значение x составляет', x)   # Значение x составляет 2

### Ключевые аргументы
Если имеется некоторая функция с большим числом параметров, и при её вызове требуется указать только некоторые из них, значения этих параметров могут задаваться по их имени – это называется ключевые параметры. В этом случае для передачи аргументов функции используется имя (ключ) вместо позиции (как было до сих пор). Есть два преимущества такого подхода: во-первых, использование функции становится легче, поскольку нет необходимости отслеживать порядок аргументов; во-вторых, можно задавать значения только некоторым избранным аргументам, при условии, что остальные параметры имеют значения аргумента по умолчанию.

    def func(a, b=5, c=10):
        print('a равно', a,', b равно', b,', а c равно', c)
    
    func(3, 7)          # a равно 3, b равно 7, а c равно 10
    func(25, c=24)      # a равно 25, b равно 5, а c равно 24
    func(c=50, a=100)   # a равно 100, b равно 5, а c равно 50

## Заняття №5. Функції, Змінне число параметрів  <a name="module05"></a>

Переменное число параметров#
Иногда бывает необходимо определить функцию, способную принимать любое число параметров. Этого можно достичь при помощи звёздочек:

    def total(a=5, *numbers, **phone_book):
        print('a', a)
        # проход по всем элементам кортежа
        for single_item in numbers:
            print('single_item', single_item)

    #проход по всем элементам словаря
    for first_part, second_part in phone_book.items():
        print(first_part,second_part)

    print(total(10, 1, 2, 3, Jack=1123, John=2231, Inge=1560))
В результате в консоли мы увидим:

    a 10
    single_item 1
    single_item 2
    single_item 3
    Jack 1123
    John 2231
    Inge 1560
    None
Когда мы объявляем параметр со звёздочкой (например, *numbers), все позиционные аргументы, начиная с этой позиции и до конца, будут собраны в кортеж под именем numbers. Аналогично, когда мы объявляем параметры с двумя звёздочками (**phone_book), все ключевые аргументы, начиная с этой позиции и до конца, будут собраны в словарь под именем phone_book.

### Рекурсия
Рекурсивная функция — это функция, определяемая в терминах самой себя и способная вызывать саму себя. Это значит, что функция будет вызывать себя и повторять свое поведение до тех пор, пока не будет выполнено некоторое условие для возврата результата.

Наиболее частый пример использование рекурсивных функций — это вычисление факториала. Для начала напомним определение факториала из математики: факториал натурального числа n определяется как произведение всех натуральных чисел от 1 до n включительно. Например: 5! = 1 · 2 · 3 · 4 · 5 = 120. Это же определение можно записать рекурсивно

    def factorial(n):
        if n <= 1:
            return 1
        else:
            return n * factorial(n - 1)
    
    factorial(5)    # 120

### Точка входа
Что же делать, когда мы хотим сделать исполняемый скрипт (который можно вызвать из консоли командой python [имя скрипта]), но сохранить возможность импорта из этого модуля, не вызывая его? В таких случаях нам может помочь служебная переменная Python: __name__. Дело в том, что если скрипт вызван непосредственно, то он является "точкой входа" и __name__ == "__main__". Если же этот модуль исполняется во время импорта, то __name__ == "hello" (например для модуля, который называется hello.py). Таким образом мы можем модифицировать наш модуль hello.py:

    def say_hello(name):
        print(f'Hello {name}')

    if __name__ == '__main__':
        print("You imported hello.py")
        say_hello('user')
